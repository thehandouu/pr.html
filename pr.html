<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Полный курс по ООП</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background-color: #f9f9f9;
            color: #333;
        }
        header {
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
            border-bottom: 5px solid #1abc9c;
        }
        nav {
            background: #1abc9c;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }
        nav a {
            color: white;
            text-decoration: none;
            font-weight: bold;
        }
        nav a:hover {
            text-decoration: underline;
        }
        section {
            max-width: 1000px;
            margin: 30px auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        h2 {
            color: #2c3e50;
        }
        ul {
            line-height: 1.8;
        }
        code, pre {
            background: #f0f0f0;
            padding: 10px;
            display: block;
            border-radius: 6px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
<header>
    <h1>Полный курс по Объектно-Ориентированному Программированию (ООП)</h1>
    <p>Теория, примеры, паттерны, языки и практика</p>
</header>
<nav>
    <a href="#intro">Введение</a>
    <a href="#principles">Принципы</a>
    <a href="#benefits">Преимущества</a>
    <a href="#classes">Классы и Объекты</a>
    <a href="#compare">Сравнение</a>
    <a href="#example">Примеры</a>
    <a href="#tasks">Практика</a>
    <a href="#patterns">Паттерны</a>
    <a href="#languages">Языки</a>
    <a href="#resources">Полезные Ресурсы</a>
</nav>

<section id="intro">
    <h2>Что такое ООП?</h2>
    <p>Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции объектов, которые объединяют в себе данные и методы для работы с ними. Оно позволяет моделировать реальный мир, создавая классы и объекты, обладающие свойствами и поведением.</p>
    
    <p>При разработке приложений с использованием ООП программисты работают с объектами реального мира, такими как пользователи, автомобили, товары и другие сущности, применяя их характеристики и поведение для решения конкретных задач.</p>
</section>

<section id="principles">
    <h2>Основные принципы ООП</h2>
    <ol>
        <li><strong>Инкапсуляция</strong> — механизм ограничения прямого доступа к внутренним данным объекта, позволяя контролировать доступ через специальные методы (геттеры и сеттеры). Это обеспечивает безопасность и независимость от изменений внутренней реализации классов.</li>
        
        <li><strong>Наследование</strong> — возможность создавать новые классы на основе существующих, заимствуя функциональность родительского класса и дополняя её новой функциональностью. Наследование помогает сократить дублирование кода и упрощает поддержку и развитие проекта.</li>
        
        <li><strong>Полиморфизм</strong> — способность одного метода вести себя различным образом в зависимости от типа объекта, к которому он применяется. Полиморфизм позволяет писать универсальный код, способный обрабатывать разные типы объектов единым способом.</li>
        
        <li><strong>Абстракция</strong> — процесс выделения общих свойств и поведения объектов, игнорируя специфичные детали реализации. Абстракция используется для создания обобщённых классов и методов, скрывающих сложность внутренних механизмов и облегчающих понимание и модификацию кода.</li>
    </ol>
</section>

<section id="benefits">
    <h2>Преимущества ООП</h2>
    <ul>
        <li>**Модульность**: Код легко структурируется, каждый класс является отдельной единицей разработки, независимой от других частей системы.</li>
        <li>**Читаемость и поддержка**: Благодаря чёткой структуре и ясности классов и объектов, код становится проще читать и поддерживать даже большими командами разработчиков.</li>
        <li>**Масштабируемость**: Возможность расширения функционала путём добавления новых классов и методов без изменения основного кода делает проекты масштабируемыми и устойчивыми к изменениям требований.</li>
        <li>**Безопасность**: Инкапсуляция защищает внутренние данные объектов, предотвращая нежелательные манипуляции извне.</li>
        <li>**Эффективность повторного использования**: Классы и объекты могут повторно использоваться в разных частях приложения или проектов, сокращая затраты на написание нового кода.</li>
    </ul>
</section>

<section id="classes">
    <h2>Классы и Объекты</h2>
    <p>Класс — это своего рода схема или шаблон, определяющий структуру и поведение будущих объектов. Например, класс "Автомобиль" определяет общие характеристики всех автомобилей (марка, модель, скорость и т.п.) и их поведение (ускоряться, тормозить и т.д.). Объект же — это конкретный экземпляр класса ("Мерседес E-класса").</p>
    
    <p>Каждый объект имеет своё уникальное состояние (например, конкретные значения переменных) и может вызывать методы, определённые в классе, для выполнения действий над собой.</p>
</section>

<section id="compare">
    <h2>ООП vs Процедурное программирование</h2>
    <p>Основное отличие между этими двумя подходами заключается в организации и представлении кода:</p>
    <ul>
        <li>**Процедурное программирование**: Фокусируется на последовательном выполнении инструкций, разбитых на процедуры и функции. Логика строится вокруг операций с глобальными переменными и структурами данных.</li>
        <li>**ООП**: Основывается на объектах, содержащих данные и методы для обработки этих данных. Структура и логика приложения выстраиваются вокруг взаимодействия объектов друг с другом.</li>
    </ul>
</section>

<section id="example">
    <h2>Примеры кода (Python)</h2>
    <p>Простой пример класса с методами:</p>
    <pre><code>class Person:
    def __init__(self, name):
        self.name = name

    def say_hello(self):
        print(f"Привет, меня зовут {self.name}.")

person = Person("Иван")
person.say_hello()</code></pre>

    <p>Здесь мы создаём простой класс Person, инициализирующий свойство name и метод say_hello. Мы создаем объект класса и вызываем его метод.</p>
</section>

<section id="tasks">
    <h2>Практические задания</h2>
    <ul>
        <li>Создать класс автомобиля (Car) с атрибутами марка, модель, год выпуска и методами ускорения и торможения.</li>
        <li>Реализовать класс студента (Student), включающий поля ФИО, возраст, факультет и метод представления самого себя.</li>
        <li>Создать абстрактный класс животного (Animal) и наследников кошек (Cat) и собак (Dog), реализующих общий интерфейс общения.</li>
    </ul>
</section>

<section id="patterns">
    <h2>Паттерны проектирования</h2>
    <p>Паттерны проектирования — это шаблоны решений типовых проблем, встречающихся при создании программного обеспечения. Они помогают разработчикам решать распространённые проблемы архитектуры и дизайна ПО стандартизированным способом.</p>

    <h3>Классификация паттернов</h3>
    <ul>
        <li><strong>Порождающие</strong> — обеспечивают создание объектов удобным и эффективным способом: **Singleton**, **Abstract Factory**, **Builder**, **Prototype**. Эти паттерны решают проблему создания объектов, сохраняя простоту и гибкость.</li>
        <li><strong>Структурные</strong> — позволяют организовать связи между компонентами и уменьшить сложности системы: **Adapter**, **Bridge**, **Composite**, **Decorator**, **Facade**, **Proxy**. Они повышают модульность и упрощают интеграцию компонентов.</li>
        <li><strong>Поведенческие</strong> — управляют процессом взаимодействия объектов и определяют алгоритмы обмена сообщениями: **Observer**, **Strategy**, **Command**, **State**, **Iterator**, **Mediator**. Они делают систему гибче и легче поддерживаемой.</li>
    </ul>

    <h3>Примеры паттернов</h3>

    <h4>Singleton (Одиночка)</h4>
    <p>Обеспечивает наличие единственного экземпляра класса и предоставляет глобальную точку доступа к нему.</p>
    <pre><code>class Singleton:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance</code></pre>

    <h4>Factory Method</h4>
    <p>Позволяет делегировать создание объектов подклассам, предоставляя общий интерфейс для создания экземпляров различных типов.</p>
    <pre><code>class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Гав!"

class Cat(Animal):
    def speak(self):
        return "Мяу!"

class AnimalFactory:
    def create_animal(self, animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()</code></pre>
</section>

<section id="languages">
    <h2>Языки программирования с поддержкой ООП</h2>
    <p>Большинство современных языков поддерживают концепцию ООП. Вот некоторые из наиболее популярных:</p>
    <ul>
        <li>Python</li>
        <li>Java</li>
        <li>C++</li>
        <li>C#</li>
        <li>Ruby</li>
        <li>JavaScript (начиная с версии ES6+)</li>
        <li>Swift</li>
        <li>Kotlin</li>
    </ul>

    <h3>Пример на Python</h3>
    <pre><code>class Person:
    def __init__(self, name):
        self.name = name

    def greet(self):
        print(f"Привет, я {self.name}")

p = Person("Игорь")
p.greet()</code></pre>

    <h3>Пример на Java</h3>
    <pre><code>public class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    public void greet() {
        System.out.println("Привет, я " + name);
    }
}

// Использование:
Person p = new Person("Анна");
p.greet();</code></pre>

    <h3>Пример на C#</h3>
    <pre><code>using System;

class Person {
    public string Name { get; set; }

    public Person(string name) {
        Name = name;
    }

    public void Greet() {
        Console.WriteLine($"Привет, я {Name}");
    }
}

// Использование:
var person = new Person("Сергей");
person.Greet();</code></pre>

    <h3>Пример на JavaScript</h3>
    <pre><code>class Person {
    constructor(name) {
        this.name = name;
    }

    greet() {
        console.log(Привет, я ${this.name});
    }
}

const person = new Person('Марина');
person.greet();</code></pre>
</section>

<section id="resources">
    <h2>Полезные ресурсы для дальнейшего изучения</h2>
    <ul>
        <li><a href="https://refactoring.guru/ru/design-patterns">Design Patterns Guide (Refactoring.guru)</a> — руководство по популярным паттернам проектирования.</li>
        <li><a href="https://pythonworld.ru/osnovy/oop-klassy-i-obekty.html">Основы ООП на примере Python</a> — хорошая статья с примерами и пояснениями.</li>
        <li><a href="https://metanit.com/java/tutorial/3.1.php">Метанит: уроки по ООП в Java</a> — понятное введение в основы ООП на Java.</li>
        <li><a href="https://www.w3schools.com/js/js_object_definition.asp">W3Schools: Object-Oriented Programming in JavaScript</a> — справочник по основам ООП на JavaScript.</li>
    </ul>
</section>

</body>
</html>
